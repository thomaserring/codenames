<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Image Codenames — Board</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1726;
      --text:#e6eefc;
      --muted:#9fb0cc;
      --border:rgba(255,255,255,.10);
      --shadow:rgba(0,0,0,.35);
      --radius:18px;

      --red:  239, 68, 68;
      --blue: 59, 130, 246;
      --gray: 148, 163, 184;
      --black: 2, 6, 23;

      --gap: 14px;
      --sideW: 320px;
      --boardSize: 600px; /* JS updates */
    }

    *{box-sizing:border-box}
    html, body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 900px at 15% 0%, #142a55 0%, var(--bg) 55%);
      color:var(--text);
      overflow:hidden;
    }

    .app{
      height: 100vh;
      height: 100dvh;
      display:grid;
      grid-template-columns: 1fr var(--sideW);
      gap: var(--gap);
      padding: var(--gap);
      padding-top: calc(var(--gap) + env(safe-area-inset-top));
      padding-bottom: calc(var(--gap) + env(safe-area-inset-bottom));
      padding-left: calc(var(--gap) + env(safe-area-inset-left));
      padding-right: calc(var(--gap) + env(safe-area-inset-right));
    }

    .boardArea{
      display:flex;
      align-items:center;
      justify-content:center;
      min-width:0;
    }

    .board{
      width: var(--boardSize);
      height: var(--boardSize);
    }

    .grid{
      width:100%;
      height:100%;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 10px;
    }

    .tile{
      position:relative;
      border-radius: 16px;
      overflow:hidden;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
      transform: translateZ(0);
    }

    .tile img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      transform: scale(1.02);
    }

    .tile.selected{
      outline: 3px solid rgba(94,234,212,.60);
      outline-offset: 2px;
    }

    /* semi-transparent reveal overlay */
    .revealOverlay{
      position:absolute; inset:0;
      opacity:0;
      transition: opacity .16s ease;
      display:flex;
      align-items:flex-end;
      padding:10px;
      pointer-events:none;
    }
    .tile.revealed .revealOverlay{ opacity:1; }

    .tag{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(6px);
      font-size:12px;
      font-weight:900;
      letter-spacing:.2px;
      color: rgba(255,255,255,.92);
    }
    .dotSmall{ width:10px; height:10px; border-radius:999px; background: rgba(255,255,255,.92); }

    .tile.revealed{ cursor:default; }
    .tile.revealed.selected{ outline:none; }

    /* Tile action bar */
    .actions{
      position:absolute;
      left:8px; right:8px; bottom:8px;
      display:none;
      gap:8px;
      z-index:5;
    }
    .tile.selected:not(.revealed) .actions{ display:flex; }

    .act{
      flex:1;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,18,30,.75);
      color: var(--text);
      font-weight:900;
      cursor:pointer;
      display:flex; gap:8px;
      align-items:center; justify-content:center;
      backdrop-filter: blur(10px);
      box-shadow: 0 16px 30px rgba(0,0,0,.32);
      user-select:none;
    }
    .act:hover{ background: rgba(12,18,30,.90); }
    .act svg{ width:18px; height:18px; }
    .act.replace{ border-color: rgba(94,234,212,.35); }
    .act.cancel{ flex:0.75; border-color: rgba(248,113,113,.35); }

    /* Right panel */
    .side{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,38,.72);
      border-radius: var(--radius);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
      overflow:hidden;
    }

    .head{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background:#5eead4;
      box-shadow:0 0 18px rgba(94,234,212,.35);
    }
    .title{ font-weight:950; font-size:16px; margin:0; }
    .sub{ font-size:12px; color:var(--muted); margin-top:2px; line-height:1.25; }

    .pillrow{ display:flex; gap:10px; flex-wrap:wrap; }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      font-size:12px;
    }
    .pill code{ font-weight:950; letter-spacing:.6px; }

    .btnrow{ display:flex; gap:10px; }
    .btn{
      flex:1;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:950;
      display:flex; gap:8px; align-items:center; justify-content:center;
      user-select:none;
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn.danger{ background: rgba(248,113,113,.14); border-color: rgba(248,113,113,.35); }
    .btn svg{ width:18px; height:18px; }

    .qr{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .qr img{
      width:128px; height:128px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
    }
    .smallMuted{ font-size:12px; color: var(--muted); line-height:1.25; }
    .smallMuted a{ color: var(--text); text-decoration:none; border-bottom:1px dashed rgba(255,255,255,.25); }

    .status{ font-size:12px; color: var(--muted); min-height:18px; }
    .error{ color:#fca5a5; font-weight:950; }

    @media (max-width: 900px){
      /* On small screens: stack (still no scroll). Sidebar overlays via <details>. */
      .app{ grid-template-columns: 1fr; }
      .side{ display:none; }
    }

    /* Simple menu button for small screens */
    details.menu{
      display:none;
      position:fixed;
      right:14px;
      top: calc(14px + env(safe-area-inset-top));
      z-index:50;
    }
    details.menu > summary{
      list-style:none;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,18,30,.78);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:950;
      box-shadow: 0 18px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      user-select:none;
    }
    details.menu > summary::-webkit-details-marker{ display:none; }

    .menuPanel{
      margin-top:10px;
      width: min(92vw, 420px);
      max-height: calc(100dvh - 100px);
      overflow:auto;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,38,.92);
      border-radius: var(--radius);
      box-shadow: 0 22px 50px rgba(0,0,0,.55);
      padding:14px;
    }
    @media (max-width: 900px){
      details.menu{ display:block; }
    }
  </style>
</head>
<body>

  <details class="menu" id="menuDetails">
    <summary>Menu</summary>
    <div class="menuPanel" id="menuPanel"></div>
  </details>

  <div class="app">
    <div class="boardArea">
      <div class="board">
        <div class="grid" id="grid"></div>
      </div>
    </div>

    <aside class="side" id="sidePanel"></aside>
  </div>

<script>
/** ---------- Deterministic RNG ---------- **/
function cyrb128(str){
  let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
  for (let i=0,k;i<str.length;i++){
    k = str.charCodeAt(i);
    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
  }
  h1 = Math.imul(h3 ^ (h1>>>18), 597399067);
  h2 = Math.imul(h4 ^ (h2>>>22), 2869860233);
  h3 = Math.imul(h1 ^ (h3>>>17), 951274213);
  h4 = Math.imul(h2 ^ (h4>>>19), 2716044179);
  return [(h1^h2^h3^h4)>>>0];
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t>>>15), t | 1);
    t ^= t + Math.imul(t ^ (t>>>7), t | 61);
    return ((t ^ (t>>>14))>>>0) / 4294967296;
  };
}
function makeRng(seedStr){ return mulberry32(cyrb128(seedStr)[0]); }
function shuffleInPlace(arr, rng){
  for (let i=arr.length-1;i>0;i--){
    const j = Math.floor(rng()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function randomSeed(){
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let out="";
  for(let i=0;i<8;i++){
    out += chars[Math.floor(Math.random()*chars.length)];
    if(i===3) out += "-";
  }
  return out;
}
function getParam(name){ return new URL(location.href).searchParams.get(name); }
function setParams(seed, deck){
  const u = new URL(location.href);
  u.searchParams.set("seed", seed);
  if (deck) u.searchParams.set("deck", deck);
  history.replaceState(null,"",u.toString());
}

/** ---------- Game rules ---------- **/
const ROLES = { RED:"red", BLUE:"blue", GRAY:"gray", BLACK:"black" };
function makeRoles(seedStr){
  const rng = makeRng(seedStr + "|roles");
  const startingTeam = rng() < 0.5 ? ROLES.RED : ROLES.BLUE;
  const starter = startingTeam;
  const other = starter === ROLES.RED ? ROLES.BLUE : ROLES.RED;

  const roles = [];
  for (let i=0;i<9;i++) roles.push(starter);
  for (let i=0;i<8;i++) roles.push(other);
  for (let i=0;i<7;i++) roles.push(ROLES.GRAY);
  roles.push(ROLES.BLACK);

  shuffleInPlace(roles, rng);
  return { roles, startingTeam };
}
function makeBag(seedStr, deckSize){
  const rng = makeRng(seedStr + "|bag");
  let bag = Array.from({length: deckSize}, (_,i)=>i);
  shuffleInPlace(bag, rng);
  let ptr = 0;

  function refill(){
    bag = Array.from({length: deckSize}, (_,i)=>i);
    shuffleInPlace(bag, rng);
    ptr = 0;
  }
  function drawNext(excludeSet){
    let attempts = 0;
    while (attempts < deckSize * 2){
      if (ptr >= bag.length) refill();
      const idx = bag[ptr++];
      if (!excludeSet.has(idx)) return idx;
      attempts++;
    }
    if (ptr >= bag.length) refill();
    return bag[ptr++ % bag.length];
  }
  return { drawNext };
}

/** ---------- UI helpers ---------- **/
function iconUndo(){return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 14l-4-4 4-4"></path><path d="M5 10h9a6 6 0 1 1 0 12h-2"></path></svg>`;}
function iconRefresh(){return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-3-6.7"></path><path d="M21 3v6h-6"></path></svg>`;}
function iconSwap(){return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 1-9 9"></path><path d="M3 12a9 9 0 0 1 9-9"></path><path d="M16 16l-4 4 4 4" transform="translate(0,-8)"></path><path d="M8 8l4-4-4-4" transform="translate(0,8)"></path></svg>`;}
function iconEye(){return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7S2 12 2 12Z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;}
function iconX(){return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"></path><path d="M6 6l12 12"></path></svg>`;}

function overlayStyle(role){
  if (role === ROLES.RED) return `background: rgba(var(--red), .78);`;
  if (role === ROLES.BLUE) return `background: rgba(var(--blue), .78);`;
  if (role === ROLES.GRAY) return `background: rgba(var(--gray), .72);`;
  return `background: rgba(var(--black), .78);`;
}
function dotStyle(role){
  if (role === ROLES.RED) return `background: rgba(var(--red), .95);`;
  if (role === ROLES.BLUE) return `background: rgba(var(--blue), .95);`;
  if (role === ROLES.GRAY) return `background: rgba(var(--gray), .95);`;
  return `background: rgba(var(--black), .95);`;
}
function roleLabel(role){
  if (role === ROLES.RED) return "RED";
  if (role === ROLES.BLUE) return "BLUE";
  if (role === ROLES.GRAY) return "NEUTRAL";
  return "ASSASSIN";
}

/** ---------- State ---------- **/
const gridEl = document.getElementById("grid");
const sidePanelEl = document.getElementById("sidePanel");
const menuPanelEl = document.getElementById("menuPanel");
const menuDetails = document.getElementById("menuDetails");

let deck = null;
let state = null;  // { seed, roles, startingTeam, tileImgIdx, revealed }
let bag = null;
let selectedIdx = null;
let actionStack = [];

/** ---------- Rendering ---------- **/
function clearSelection(){
  selectedIdx = null;
  document.querySelectorAll(".tile.selected").forEach(el => el.classList.remove("selected"));
}
function buildMapUrl(){
  const u = new URL(location.href);
  const base = u.toString().split("?")[0];
  const mapUrl = base.replace(/board\.html$/i, "map.html");
  const deckParam = getParam("deck") || "deck.json";
  const out = new URL(mapUrl);
  out.searchParams.set("seed", state.seed);
  out.searchParams.set("deck", deckParam);
  return out.toString();
}

function renderPanel(container){
  container.innerHTML = `
    <div class="head">
      <div class="dot"></div>
      <div>
        <div class="title">Image Codenames</div>
        <div class="sub">Tap a tile → Replace / Reveal / Cancel</div>
      </div>
    </div>

    <div class="pillrow">
      <div class="pill">Deck: <code data-k="deckName">…</code></div>
      <div class="pill">Seed: <code data-k="seedText">…</code></div>
      <div class="pill">Start: <code data-k="startTeam">…</code></div>
    </div>

    <div class="btnrow">
      <button class="btn" data-k="undoBtn" disabled>${iconUndo()} Undo</button>
      <button class="btn danger" data-k="newBtn">${iconRefresh()} New map</button>
    </div>

    <div class="qr">
      <div style="flex:1; min-width:160px;">
        <div class="smallMuted">Scan to open spymaster map:</div>
        <div class="smallMuted"><a data-k="mapLink" href="#" target="_blank" rel="noopener">Open map link</a></div>
      </div>
      <img data-k="qrImg" alt="QR code">
    </div>

    <div class="status" data-k="status"></div>
  `;

  container.querySelector('[data-k="undoBtn"]').addEventListener("click", undo);
  container.querySelector('[data-k="newBtn"]').addEventListener("click", newMap);
}
function setPanelValues(container){
  container.querySelector('[data-k="seedText"]').textContent = state.seed;
  container.querySelector('[data-k="deckName"]').textContent = deck?.name || "Deck";
  container.querySelector('[data-k="startTeam"]').textContent = (state.startingTeam === ROLES.RED) ? "RED (9)" : "BLUE (9)";

  const mapUrl = buildMapUrl();
  container.querySelector('[data-k="mapLink"]').href = mapUrl;
  container.querySelector('[data-k="qrImg"]').src =
    "https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=" + encodeURIComponent(mapUrl);

  container.querySelector('[data-k="undoBtn"]').disabled = actionStack.length === 0;
}
function setStatusAll(msg, isError=false){
  for (const c of [sidePanelEl, menuPanelEl]){
    const s = c.querySelector('[data-k="status"]');
    if (!s) continue;
    s.textContent = msg || "";
    s.className = "status" + (isError ? " error" : "");
  }
}
function updateUndoButtons(){
  for (const c of [sidePanelEl, menuPanelEl]){
    const b = c.querySelector('[data-k="undoBtn"]');
    if (b) b.disabled = actionStack.length === 0;
  }
}

function renderBoard(){
  renderPanel(sidePanelEl);
  renderPanel(menuPanelEl);
  setPanelValues(sidePanelEl);
  setPanelValues(menuPanelEl);

  gridEl.innerHTML = "";
  for (let i=0;i<25;i++){
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.idx = String(i);

    tile.innerHTML = `
      <img alt="tile image" draggable="false" />
      <div class="revealOverlay" style="${overlayStyle(state.roles[i])}">
        <div class="tag">
          <span class="dotSmall" style="${dotStyle(state.roles[i])}"></span>
          <span>${roleLabel(state.roles[i])}</span>
        </div>
      </div>
      <div class="actions">
        <button class="act replace">${iconSwap()} Replace</button>
        <button class="act reveal">${iconEye()} Reveal</button>
        <button class="act cancel">${iconX()}</button>
      </div>
    `;

    tile.addEventListener("click", (e) => {
      const idx = Number(tile.dataset.idx);
      if (state.revealed[idx]) return;
      if (e.target.closest(".act")) return;
      if (selectedIdx === idx) clearSelection();
      else { clearSelection(); selectedIdx = idx; tile.classList.add("selected"); }
    });

    tile.querySelector(".act.cancel").addEventListener("click", (e)=>{ e.stopPropagation(); clearSelection(); });
    tile.querySelector(".act.reveal").addEventListener("click", (e)=>{ e.stopPropagation(); reveal(i); clearSelection(); });
    tile.querySelector(".act.replace").addEventListener("click", (e)=>{ e.stopPropagation(); replace(i); clearSelection(); });

    gridEl.appendChild(tile);
    renderTile(i);
  }

  setStatusAll("Ready.");
}

function renderTile(i){
  const tile = gridEl.querySelector(`.tile[data-idx="${i}"]`);
  if (!tile) return;
  tile.querySelector("img").src = deck.images[state.tileImgIdx[i]].src;
  tile.classList.toggle("revealed", !!state.revealed[i]);
}

/** ---------- Actions ---------- **/
function undo(){
  const a = actionStack.pop();
  if (!a) return;
  if (a.type === "reveal"){ state.revealed[a.idx] = false; renderTile(a.idx); }
  if (a.type === "replace"){ state.tileImgIdx[a.idx] = a.prev; renderTile(a.idx); }
  updateUndoButtons();
}
function newMap(){
  if (!confirm("Create a NEW map and NEW images? (This resets the board)")) return;
  const deckParam = getParam("deck") || "deck.json";
  const seed = randomSeed();
  const u = new URL(location.href);
  u.searchParams.set("seed", seed);
  u.searchParams.set("deck", deckParam);
  location.href = u.toString();
}
function reveal(idx){
  if (state.revealed[idx]) return;
  state.revealed[idx] = true;
  actionStack.push({type:"reveal", idx});
  updateUndoButtons();
  renderTile(idx);
  try { if (navigator.vibrate) navigator.vibrate(12); } catch(_) {}
}
function replace(idx){
  if (state.revealed[idx]) return;
  const exclude = new Set(state.tileImgIdx);
  const next = bag.drawNext(exclude);
  const prev = state.tileImgIdx[idx];
  if (next === prev) return;
  state.tileImgIdx[idx] = next;
  actionStack.push({type:"replace", idx, prev});
  updateUndoButtons();
  renderTile(idx);
}

/** Close selection if clicking outside tiles */
document.addEventListener("click", (e)=>{ if (!e.target.closest(".tile")) clearSelection(); });

/** Fit board perfectly to viewport */
function computeBoardSize(){
  const gap = 14;
  const isWide = window.matchMedia("(min-width: 901px)").matches;
  const sideW = isWide ? 320 : 0;
  const availW = window.innerWidth - sideW - (gap*3);
  const availH = window.innerHeight - (gap*2);
  const size = Math.max(260, Math.floor(Math.min(availW, availH)));
  document.documentElement.style.setProperty("--boardSize", size + "px");
}
window.addEventListener("resize", computeBoardSize);
window.addEventListener("orientationchange", computeBoardSize);

/** Boot */
async function loadDeck(deckUrl){
  const res = await fetch(deckUrl, { cache: "no-store" });
  if (!res.ok) throw new Error("Failed to fetch " + deckUrl + " (" + res.status + ")");
  const d = await res.json();
  if (!d?.images || !Array.isArray(d.images)) throw new Error("deck.json must have { images: [...] }");
  if (d.images.length < 25) throw new Error("Deck must contain at least 25 images.");
  return d;
}

function init(seedStr){
  const { roles, startingTeam } = makeRoles(seedStr);

  const rng = makeRng(seedStr + "|images");
  const allIdx = Array.from({length: deck.images.length}, (_,i)=>i);
  shuffleInPlace(allIdx, rng);
  const tileImgIdx = allIdx.slice(0,25);

  state = { seed: seedStr, roles, startingTeam, tileImgIdx, revealed: Array(25).fill(false) };
  bag = makeBag(seedStr, deck.images.length);
  actionStack = [];
}

(async function(){
  try{
    computeBoardSize();
    const deckParam = getParam("deck") || "deck.json";
    let seedParam = getParam("seed");
    if (!seedParam) seedParam = randomSeed();
    setParams(seedParam, deckParam);

    deck = await loadDeck(deckParam);
    init(seedParam);
    renderBoard();
    // if menu open on mobile and you tap buttons, close it
    menuDetails.addEventListener("toggle", () => {});
  } catch(err){
    console.error(err);
    renderPanel(sidePanelEl);
    renderPanel(menuPanelEl);
    setStatusAll(err.message || String(err), true);
  }
})();
</script>
</body>
</html>
